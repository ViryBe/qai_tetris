\documentclass{article}
\usepackage{fontspec}
\usepackage{polyglossia}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{unicode-math}
\usepackage{amsmath}
\usepackage{listings}

\setmainlanguage{french}

\newcommand{\R}{\mathbb{R}}

\DeclareMathOperator{\card}{card}

\title{Ocaml---IA\\Tetris par Qlearning}
\author{C.~Cousin, G.~Hondet, L.~Pineau, B.~Viry}
\date{\today}


\begin{document}
\maketitle
\tableofcontents

\section*{Introduction}

\section*{Notations}
Seront not\'es dans tout l'ouvrage:
\begin{itemize}
  \item \(n_t\) le nombre de tetrominos par jeu,
  \item \(\mathcal{S}\) l'ensemble des \'etats,
  \item \(b_w, b_h\) la largeur et la hauteur totale du plateau.
\end{itemize}
Sauf mention explicite, les applications utiliseront les valeurs \(n_t=10,000,
b_w = 6\). Seront distingu\'ees la hauteur totale \(b_h\) et la hauteur relative
à un instant de jeu \(h\) du plateau, la première correspond à la hauteur
théorique maximale atteignable quand la deuxieme concerne la hauteur
effectivement atteinte à un instant de jeu, i.e.\ le nombre de lignes non vides
sur le plateau.

\section{Tetris}

\subsection{Le jeu et sa simplification}
Tetris met le joueur au défi de réaliser des lignes complètes en déplaçant des
pièces de formes différentes, les tétrominos, qui défilent depuis le haut
jusqu'au bas de l'écran. Les lignes complétées disparaissent tout en rapportant
des points et le joueur peut de nouveau remplir les cases libérées. Le jeu
n'a pas de fin: le joueur perd la partie lorsqu'un tétrimino reste bloqué en
haut.

Dans notre version simplifiée, il n'y a pas de limite de hauteur, le jeu se
termine apres avoir fourni 10,000 tetrominos à placer. De plus notre
tetris diffère par une grille plus étroite (6 colonnes disponibles), moins de
tetrominos différents (seulement 5) et des tetrominos plus petits (taille
inférieure à 2).

Un tetromino est plac\'e par le choix d'une colonne et d'une orientation.

\subsection{L'impl\'ementation}

\subsubsection{Représentation}

\paragraph{Tetrominos}
Les tetrominos sont tableaux de longueur 4. L'unidimensionnalit\'e permet
d'impl\'ementer les rotations comme des transformations d'indices, \'evitant la
cr\'eation ou la modification de structures.

IMAGE NED EED\\
Les tetrominos sont tous de même dimension par souci d'homogénéite.

\paragraph{Plateau \texttt{Board}}
Le plateau est repr\'esent\'e par une matrice de dimension
\(2\cdot n_t\cdot 6\) d'entiers dans laquelle on inscrit les tetrominos. Les
manipulations du plateau se font en place.


\paragraph{Actions}
Composées d'une rotation et d'une translation. Elles permettent d'agir sur les
tetrominos. Les rotations sont representées par les points cardinaux
(North, South, East, West) et les translations par un entier compris entre 0 et
4 correspondant à l'indice du coin supérieur gauche du tetromino.

POINT DE REF

\subsection{D\'eroulement d'une partie}
Lors d'une partie le joueur doit poser les pièces qui lui sont proposées sur
le plateau de jeu. Il est donc nécessaire d'utiliser une fonction \texttt{play}
qui permet de placer une pièce sur le plateau. La pièce ``tombe'' donc dans la
colonne sélectionnée tant qu'elle ne rencontre pas d'obstacle (fond du plateau
ou un autre tétromino). Pour cela, il y a besoin d'une fonction de test de
collision, qui renvoie si l'emplacement testé peut accueillir le tetromino.
S'il y a collision, on sélectionne le dernier emplacement libre et on place la
pièce.

Lorsqu'une ligne est entièrement remplie, elle est supprimée du tableau, mais
la taille totale du plateau reste la même.

\subsection{Drawbacks}
\subsubsection{Fonction collide}
L'implementation actuelle oblige l'accessibilit\'e de la position finale depuis
le haut du plateau car la pi\`ece ne peut pas \^etre gliss\'ee au dernier moment
sous une autre.
\subsubsection{Tetromino}
Les tetrominos sont tous de même dimension par souci d'homogeneite et cela
peut entrainer un probleme de ``tetromino flottant''. Ce problème est traité par
un choix d'action spécifique à chaque pièce (cf partie x).
\section{Q learning}

\subsection{Représentation des états}
\subsubsection{Composition}
Intuitivement, un état correspond à la pièce donnée à jouer et la disposition
des pièces sur le plateau. En notant \(n_t\) le nombre de tetrominos et \(w\) la
largeur du plateau, on obtient \(5 \cdot 2^{wn_t}\) états possibles.

Pour reduire le nombre d'états, on ne considère que les deux plus hautes lignes
contenant au moins un tetromino. On obtient \(5\cdot 2^{w+1}\) états possibles,
soit \(20,480\) pour une largeur de 6.

\subsubsection{Codage}
Comme chaque état correspond \textit{in fine} à une ligne de la matrice, il est
nécessaire d'avoir une bijection entre l'ensemble des états et les entiers. La
bijection genère deux représentations entières, une pour les deux lignes de
l'état et l'autre pour la pièce et les combine en un état entier final,
\[
  \texttt{get\_state}\colon [0,4]\times [0, 2^{12} - 1] \to [0, 5\cdot 2^{12}].
\]


\subsection{Algorithmes}

\subsection{Param\`etres}
\subsubsection{Pr\'esentation}
L'apprentissage est paramétré par les trois variables,
\begin{itemize}
  \item \(\alpha \in [0, 1]\) le taux d'apprentissage,
  \item \(\epsilon \in [0, 1]\) la fréquence de coups aléatoires effectués,
  \item \(\gamma \in [0, 1]\) la vision de l'agent.
\end{itemize}
%TODO ne veut rien dire !!!!
Pour assurer la convergence de la matrice vers la matrice optimale,
le taux d'apprentissage évolue au cours des entrainements, est utilisée une
suite \( (\alpha_k)_k \). D'après~\cite{watkins92}, la suite \(
(\alpha_k)_k \) doit vérifier \( \sum_{k=0}^\infty \alpha_k = \infty \) et \(
\sum_{k=0}^\infty \alpha_k^2 \in \R \). La suite choisie est donc, pour tout
\( k \in \mathbb{N} \) et avec \( C \in \R \)
\[
  \alpha_k = \frac{1}{1 + Ck}.
\]
Le taux d'apprentissage reste manipulable via le paramètre \( C \).


Le paramètre \(\epsilon\) pourra \'egalement varier au cours des jeux effectués.
En effet, intuitivement, un \(\epsilon\) grand permet une exploration rapide de
l'ensemble des états possibles mais devient nuisible lorsque la matrice est bien
entrainée.

\subsubsection{Valeurs}
Par défaut les valeurs utilisées


\section{Difficultés rencontrées}

\subsection{Le fl\'eau de la mutabilit\'e}
L'usage du \texttt{Array.blit} s'est revélé plus delicat que prevu. En
considerant que la ligne \(l\) doit etre supprimée et en notant \(h\) la hauteur
actuelle du plateau, le principe est de copier la section de tableau incluant
les lignes \(l+1\) jusqu'à \(h+1\) une ligne en dessous, i.e.\ translater le
bloc d'une ligne vers le bas.

Cette démarche engendre des comportements anormaux car la ligne \(h+1\) n'est
pas copiée sur la ligne \(h\), elles partagent la même adresse mémoire. Ainsi,
il etait observé quelques coups après un blit un dédoublement de carrés de
tetrominos, faisant augmenter la hauteur.

Pour pallier ce problème de partage d'adresse mémoire, la ligne \(h\) est
recréée à chaque blit.

\section{R\'esultats du projet}

\section*{Conclusion}

\appendix
\section{Deep Q learning}

\begin{thebibliography}{9}
    \bibitem{watkins92}
    Christopher~J.C.H.~Watkins, Peter~Dayan
    \textit{Q-Learning, Machine Learning}
    1992.
    \bibitem{deepmind}
    Voloddymyr~Mnih, Koray Kavukcuoghlu, David Silver, Alex Graves, Ioannis
    Antonoglou, Daan Wierstra, Martin Riedmiller,
    \textit{Playing Atari with Deep Reinforcement Learning}
\end{thebibliography}

\end{document}
